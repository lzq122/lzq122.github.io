引用网络时序路径可视化分析系统——by ylx
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>引用网络时序路径可视化分析系统</title>
    <script src="https://cdn.staticfile.org/echarts/5.4.0/echarts.min.js"></script>
    <style>
        #main { width: 100%; height: 600px; }
        .controls { margin: 20px; }
        #results { 
            margin: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .result-table {
            width: 100%;
            margin-top: 15px;
            border-collapse: collapse;
        }
        .result-table th, .result-table td {
            padding: 8px;
            border: 1px solid #ddd;
            text-align: left;
        }
        .result-table th {
            background-color: #f5f5f5;
        }
        .color-legend { display: flex; gap: 15px; margin: 10px 0; }
        .color-dot { width: 12px; height: 12px; border-radius: 50%; }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="loadSampleData()" style="margin-bottom:15px;">加载示例数据</button><br>
        <input type="file" id="nodeFile" accept=".csv"> 节点文件<br>
        <input type="file" id="linkFile" accept=".csv"> 关系文件<br>
        <select id="startNode"></select> →
        <select id="endNode"></select>
        <button onclick="analyzePaths()">分析指定路径</button>
        <button onclick="analyzeGlobalPaths()" style="margin-left:20px;">全局路径分析</button>
    </div>
    <div id="main"></div>
    <div id="results">
        <h3>路径分析结果</h3>
        <div class="color-legend" id="colorLegend"></div>
        
        <div class="result-section">
            <h4>指定路径结果</h4>
            <table class="result-table" id="longestPaths"></table>
            <table class="result-table" id="topCitedPaths"></table>
        </div>

        <div class="result-section">
            <h4>全局分析结果</h4>
            <div id="globalLoading" class="loading" style="display:none;">计算中，请稍候...</div>
            <table class="result-table" id="globalLongestPaths"></table>
            <table class="result-table" id="globalTopCitedPaths"></table>
        </div>
    </div>

<script>
// 新增示例数据加载函数
function loadSampleData() {
    // 示例节点数据
    const nodeCSV = `id,title,year,citations
D1,D1,2018,45
D2,D2,2019,32
D3,D3,2020,23
D4,D4,2021,25
D5,D5,2022,25
D6,D6,2023,12
D7,D7,2024,11
D8,D8,2018,50`;

    // 示例边数据
    const linkCSV = `source,target
D1,D2
D2,D3
D3,D4
D4,D5
D5,D6
D6,D7
D1,D7
D2,D6
D8,D6
D1,D8`;

    // 解析节点数据
    documents = nodeCSV.split('\n').slice(1).map(row => {
        const [id, title, year, citations] = row.split(',');
        return {
            id: id.trim(),
            title: title.trim(),
            year: parseInt(year.trim()),
            citations: parseInt(citations.trim())
        };
    });

    // 解析边数据
    citations = linkCSV.split('\n').slice(1).map(row => {
        const [source, target] = row.split(',');
        return {
            source: source.trim(),
            target: target.trim()
        };
    });

    // 初始化系统
    initSelects();
    calculateNetworkMetrics();
    renderChart();
    alert('示例数据加载完成！');
}


let documents = [], citations = [];
let currentPaths = [], pathColors = [];
let networkMetrics = { centrality: {} };
const chartDom = document.getElementById('main');
const myChart = echarts.init(chartDom);



function parseCSV(file, callback) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const rows = e.target.result.split('\n').filter(row => row.trim());
        const headers = rows[0].split(',').map(h => h.trim());
        const data = rows.slice(1).map(row => {
            const values = row.split(',').map(v => v.trim());
            return headers.reduce((obj, h, i) => {
                obj[h] = isNaN(values[i]) ? values[i] : Number(values[i]);
                return obj;
            }, {});
        });
        callback(data);
    };
    reader.readAsText(file);
}

function initSelects() {
    const startSelect = document.getElementById('startNode');
    const endSelect = document.getElementById('endNode');
    startSelect.innerHTML = documents.map(d => 
        `<option value="${d.id}">${d.title}</option>`).join('');
    endSelect.innerHTML = documents.map(d => 
        `<option value="${d.id}">${d.title}</option>`).join('');
}

function calculatePositions() {
    documents.sort((a, b) => a.year - b.year);
    const yearGroups = documents.reduce((acc, d) => {
        acc[d.year] = (acc[d.year] || 0) + 1;
        return acc;
    }, {});

    return documents.map(d => {
        const yearCount = yearGroups[d.year];
        const x = (d.year - Math.min(...documents.map(n => n.year))) * 180 + 100;
        const index = documents.filter(n => n.year === d.year).indexOf(d);
        return {
            ...d,
            x: x,
            y: (600 / (yearCount + 1)) * (index + 1),
            fixed: true
        };
    });
}

// 修正时间轴显示问题
function createFixedTimeAxis() {
    const years = [...new Set(documents.map(d => d.year))].sort();
    const minYear = Math.min(...years);
    const maxYear = Math.max(...years);
    const yearSpan = maxYear - minYear || 1;

    return years.map(year => {
        const xPos = ((year - minYear) / yearSpan) * (chartDom.offsetWidth - 200) + 100;
        return [
            {
                type: 'line',
                z: 0,
                shape: { x1: xPos, y1: 0, x2: xPos, y2: chartDom.offsetHeight },
                style: { 
                    stroke: '#999', 
                    lineDash: [5,5],
                    lineWidth: 1
                }
            },
            {
                type: 'text',
                bottom: 0,
                left: xPos -15,
                style: {
                    text: year,
                    fill: '#666',
                    fontSize: 14
                }
            }
        ];
    }).flat();
}

function calculateNetworkMetrics() {
    networkMetrics.centrality = documents.reduce((acc, node) => {
        acc[node.id] = {
            inDegree: citations.filter(l => l.target === node.id).length,
            outDegree: citations.filter(l => l.source === node.id).length
        };
        return acc;
    }, {});

    documents.forEach(node => {
        node.totalCitationImpact = networkMetrics.centrality[node.id].inDegree * 0.6 + 
                                  node.citations * 0.4;
    });
}

async function analyzeGlobalPaths() {
    const startTime = Date.now();
    const loadingElement = document.getElementById('globalLoading');
    loadingElement.style.display = 'block';
    
    try {
        const allPaths = [];
        const nodeIds = documents.map(d => d.id);
        
        for (const startId of nodeIds) {
            for (const endId of nodeIds) {
                if (startId === endId) continue;
                const paths = findPaths(startId, endId);
                allPaths.push(...paths);
            }
        }

        const enhancedPaths = allPaths.map(path => {
            const nodes = path.map(id => documents.find(d => d.id === id));
            return {
                path: path,
                length: path.length,
                totalCitations: nodes.reduce((sum, n) => sum + n.citations, 0),
                avgCentrality: parseFloat((path.reduce((sum, id) => 
                    sum + networkMetrics.centrality[id].inDegree, 0) / path.length).toFixed(2)),
                yearsSpan: Math.max(...nodes.map(n => n.year)) - Math.min(...nodes.map(n => n.year))
            };
        });

        const validPaths = enhancedPaths.filter(p => p.length > 1);
        const longestPaths = validPaths.sort((a, b) => b.length - a.length).slice(0, 10);
        const topCitedPaths = validPaths.sort((a, b) => b.totalCitations - a.totalCitations).slice(0, 10);

        renderGlobalResultTables(longestPaths, topCitedPaths);
        
        console.log(`分析完成，耗时：${(Date.now()-startTime)/1000}秒`);
    } catch (error) {
        console.error('全局路径分析出错:', error);
    } finally {
        loadingElement.style.display = 'none';
    }
}

function renderGlobalResultTables(longestPaths, topCitedPaths) {
    const globalLongestTable = document.getElementById('globalLongestPaths');
    globalLongestTable.innerHTML = `
        <tr>
            <th>排名</th>
            <th>路径长度</th>
            <th>总被引次数</th>
            <th>文献序列</th>
        </tr>
    ` + longestPaths.map((p,i) => `
        <tr>
            <td>${i+1}</td>
            <td>${p.length}</td>
            <td>${p.totalCitations}</td>
            <td>${p.path.join(' → ')}</td>
        </tr>
    `).join('');

    const globalTopCitedTable = document.getElementById('globalTopCitedPaths');
    globalTopCitedTable.innerHTML = `
        <tr>
            <th>排名</th>
            <th>总被引次数</th>
            <th>路径长度</th>
            <th>关键文献</th>
        </tr>
    ` + topCitedPaths.map((p,i) => `
        <tr>
            <td>${i+1}</td>
            <td>${p.totalCitations}</td>
            <td>${p.length}</td>
            <td>${getKeyPapers(p.path)}</td>
        </tr>
    `).join('');
}

function findPaths(start, end, maxDepth = 8) {
    const adjacencyList = citations.reduce((acc, {source, target}) => {
        acc[source] = acc[source] || [];
        acc[source].push(target);
        return acc;
    }, {});

    const paths = [];
    (function dfs(current, path, depth) {
        if (depth > maxDepth) return;
        path.push(current);
        if (current === end) {
            paths.push([...path]);
            path.pop();
            return;
        }
        adjacencyList[current]?.forEach(next => {
            if (!path.includes(next)) dfs(next, path, depth + 1);
        });
        path.pop();
    })(start, [], 1);
    return paths;
}

// 增强路径高亮显示功能
function highlightPaths(paths) {
    pathColors = paths.map((_,i) => `hsl(${(i*360)/paths.length},70%,50%)`);
    
    const linkMap = new Map();
    paths.forEach((path, pathIndex) => {
        path.path.slice(0,-1).forEach((source, i) => {
            const target = path.path[i+1];
            const sourceName = documents.find(d => d.id === source)?.title || source;
            const targetName = documents.find(d => d.id === target)?.title || target;
            linkMap.set(`${source}-${target}`, {
                color: pathColors[pathIndex],
                curveness: 0.2,
                sourceName,
                targetName
            });
        });
    });

    const option = myChart.getOption();
    option.series[0].links = citations.map(link => {
        const enhancedLink = linkMap.get(`${link.source}-${link.target}`);
        return {
            ...link,
            sourceName: enhancedLink?.sourceName || link.sourceName,
            targetName: enhancedLink?.targetName || link.targetName,
            lineStyle: {
                color: enhancedLink?.color || '#ddd',
                width: enhancedLink ? 3 : 1,
                curveness: enhancedLink?.curveness || 0.2
            }
        };
    });
    myChart.setOption(option, true);
    
    document.getElementById('colorLegend').innerHTML = paths.map((p,i) => `
        <div style="display:flex;align-items:center;gap:5px;">
            <div class="color-dot" style="background:${pathColors[i]}"></div>
            <span>路径${i+1}</span>
        </div>
    `).slice(0,5).join('');
}

function renderResultTables(paths) {
    const longestTable = document.getElementById('longestPaths');
    longestTable.innerHTML = `
        <tr>
            <th>路径长度</th>
            <th>总被引次数</th>
            <th>文献序列</th>
            <th>时间跨度</th>
        </tr>
    ` + paths.slice(0,5).map(p => `
        <tr>
            <td>${p.length}</td>
            <td>${p.totalCitations}</td>
            <td>${p.path.join(' → ')}</td>
            <td>${p.yearsSpan}年</td>
        </tr>
    `).join('');

    const citedPaths = [...paths].sort((a,b) => b.totalCitations - a.totalCitations);
    const topCitedTable = document.getElementById('topCitedPaths');
    topCitedTable.innerHTML = `
        <tr>
            <th>总被引次数</th>
            <th>路径长度</th>
            <th>中心性均值</th>
            <th>关键文献</th>
        </tr>
    ` + citedPaths.slice(0,5).map(p => `
        <tr>
            <td>${p.totalCitations}</td>
            <td>${p.length}</td>
            <td>${p.avgCentrality}</td>
            <td>${getKeyPapers(p.path)}</td>
        </tr>
    `).join('');
}

function getKeyPapers(path) {
    return path.map(id => {
        const node = documents.find(d => d.id === id);
        return node.totalCitationImpact > 30 ? `${node.title}*` : node.title;
    }).join(' → ');
}

function tooltipFormatter(params) {
    if (params.dataType === 'node') {
        const data = params.data;
        return `
            <strong>${data.name}</strong><br>
            年份：${data.year}<br>
            被引次数：${data.value}<br>
            入度：${networkMetrics.centrality[data.id].inDegree}<br>
            出度：${networkMetrics.centrality[data.id].outDegree}
        `;
    }
    if (params.dataType === 'edge') {
        return `来源：${params.data.sourceName}<br>目标：${params.data.targetName}`;
    }
    return '';
}

function analyzePaths() {
    const start = document.getElementById('startNode').value;
    const end = document.getElementById('endNode').value;
    const rawPaths = findPaths(start, end);
    
    const enhancedPaths = rawPaths.map(path => {
        const nodes = path.map(id => documents.find(d => d.id === id));
        return {
            path: path,
            length: path.length,
            totalCitations: nodes.reduce((sum, n) => sum + n.citations, 0),
            avgCentrality: parseFloat((path.reduce((sum, id) => 
                sum + networkMetrics.centrality[id].outDegree, 0) / path.length).toFixed(2)),
            yearsSpan: Math.max(...nodes.map(n => n.year)) - Math.min(...nodes.map(n => n.year))
        };
    }).sort((a, b) => b.length - a.length);

    highlightPaths(enhancedPaths);
    renderResultTables(enhancedPaths);
}

function renderChart() {
    const nodes = calculatePositions().map(d => ({
        id: d.id,
        name: d.title,
        value: d.citations,
        x: d.x,
        y: d.y,
        year: d.year,
        symbolSize: Math.sqrt(d.citations) * 4,
        itemStyle: { color: '#5470c6' }
    }));

    const links = citations.map(link => {
        const sourceDoc = documents.find(d => d.id === link.source);
        const targetDoc = documents.find(d => d.id === link.target);
        return {
            ...link,
            sourceName: sourceDoc?.title || link.source,
            targetName: targetDoc?.title || link.target,
            lineStyle: { 
                color: '#ddd',
                curveness: 0.2,
                width: 1
            }
        };
    });

    const option = {
        title: { text: '固定布局引文分析系统' },
        toolbox: { feature: { saveAsImage: {} } },
        tooltip: { 
            formatter: tooltipFormatter,
            triggerOn: 'mousemove'
        },
        graphic: createFixedTimeAxis(),
        series: [{
            type: 'graph',
            layout: 'none',
            roam: true,
            edgeSymbol: ['none', 'arrow'],
            edgeSymbolSize: 8,
            label: { 
                show: true, 
                position: 'right',
                fontSize: 12
            },
            lineStyle: { opacity: 0.8 },
            emphasis: { 
                focus: 'adjacency',
                lineStyle: {
                    width: 2
                }
            },
            nodes, 
            links
        }]
    };
    
    myChart.setOption(option);
}

// 修改后的文件加载处理（增加数据重置）
document.getElementById('nodeFile').addEventListener('change', function(e) {
    documents = []; // 重置数据
    parseCSV(e.target.files[0], data => {
        documents = data;
        initSelects();
        if (citations.length) {
            calculateNetworkMetrics();
            renderChart();
        }
    });
});

document.getElementById('linkFile').addEventListener('change', function(e) {
    citations = []; // 重置数据
    parseCSV(e.target.files[0], data => {
        citations = data;
        if (documents.length) {
            calculateNetworkMetrics();
            renderChart();
        }
    });
});

window.addEventListener('resize', () => {
    myChart.resize();
    // 窗口大小变化时重新计算时间轴
    if (documents.length && citations.length) {
        const option = myChart.getOption();
        option.graphic = createFixedTimeAxis();
        myChart.setOption(option);
    }
});
</script>
</body>
</html>